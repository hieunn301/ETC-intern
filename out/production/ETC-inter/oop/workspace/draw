package oop.workspace;

import java.util.LinkedList;

class Stack{
    private String arr[];
    private int top;
    private int max;
    Stack(int size){
        arr = new String[size];
        max = size;
        top = -1;
    }
    public int size() {
        return top + 1;
    }
    public boolean isEmpty() {
        return top == -1;
    }
    public boolean isFull() {
        return top == max - 1;
    }
    public String push(String x){
        if (isFull()){
            System.out.println("Ngăn xếp đầy");
        }
        System.out.println("Thêm " + x);
        return arr[++top] = x;
    }
    public String pop(){
        if (isEmpty()){
            System.out.println("Ngăn xếp rỗng");
        }
        System.out.println("Xóa " + peek());
        return arr[top--];
    }
    public String peek(){
        if (!isEmpty()) {
            return arr[top];
        }else {
            System.out.println("Ngăn xếp rỗng");
        }
        return null;
    }
}

class Queue {
    private String[] arr;
    private int front;
    private int rear;
    private int max;
    private int count;

    Queue(int size){
        arr = new String[size];
        max = size;
        front = 0;
        rear = -1;
        count = 0;
    }
    public int count() {return count;}

    public boolean isEmpty() {return front == 0;}

    public boolean isFull() {return count == max ? true : false;}

    public String add(String item){
        if (isFull()){
            System.out.println("Hàng đợi đầy");
        }
        System.out.println("Thêm " + item);
        rear++;
        arr[rear] = item;
        count++;
        return item;
    }
    public String remove() {
        if (isEmpty()) {
            System.out.println("Hàng đợi rỗng");
        }
        String x = arr[front];
        System.out.println("Xóa " + x);
        front++;
        count--;
        return x;
    }
    public String peek(){
        if (isEmpty()) {
            System.out.println("Hàng đợi rỗng");
        }
        return arr[front];
    }
}

//class CustomHashMap<K, V> {
//
//    private int capacity = 16;
//
//    private Entry<K, V>[] table;
//
//    public CustomHashMap(){
//        table = new Entry[capacity];
//    }
//    public CustomHashMap(int capacity){
//        this.capacity = capacity;
//        table = new Entry[capacity];
//    }
//    public void put(K key, V value){
//    }
//    public V get(K key){
//    }
//    public void remove(K key){
//    }
//    public void display(){
//        for(int i = 0; i < capacity; i++){
//            if(table[i] != null){
//                Entry<K, V> currentNode = table[i];
//                while (currentNode != null){
//                    System.out.println(String.format("Key is %s and value is %s", currentNode.getKey(), currentNode.getValue()));
//                    currentNode = currentNode.getNext();
//                }
//            }
//        }
//    }
//    private int index(K key){
//        if(key == null){
//            return 0;
//        }
//        return Math.abs(key.hashCode() % capacity);
//    }
//}





class Map{
    private class Data{
        int key;
        int value;

        public Data(int key, int value) {
            this.key = key;
            this.value = value;
        }

        @Override
        public boolean equals(Object obj) {
            if(obj instanceof Data)
                return this.key == ((Data)obj).key;
            return false;
        }
    }
    private int size;
    private ArrayList<Data> buckets[];
    public Map(){
        buckets = new ArrayList[size];
        for(int i = 0; i < buckets.length; i++){
            buckets[i] = new ArrayList<>();
        }
    }
//    private int hashFunction(int key){
//        return key % size;
//    }
    public void put(int key, int value){
//        int hashValueIndex = hashFunction(key);
//        ArrayList<Data> bucket = buckets[hashValueIndex];
//        Data newData = new Data(key, 0);
//        int keyIndex = bucket.indexOf(newData);
//        if(keyIndex >= 0){
//            bucket.get(keyIndex).value = value;
//        }else{
//            bucket.add(newData);
//            System.out.println(hashValueIndex + " = " + value);
//        }
        size++;
        System.out.println(key + " = " + value);
    }
    public void remove(int key){
    }
    public int size(){
        System.out.println("size: " + size);
        return size;
    }
    public int get(int key){
        return key;
    }
}



class Map<K, V> {
    public static class Entry<K, V> {
        private final K key;
        private V value;
        private Entry<K, V> next;

        public Entry(K key, V value, Entry<K, V> next){
            this.key = key;
            this.value = value;
            this.next = next;
        }
        public K getKey() {return key;}
        public V getValue() {return value;}
        public void setValue(V value) {this.value = value;}
        public Entry getNext() {return next;}
        public void setNext(Entry<K, V> next) {this.next = next;}
    }
    private int size = 10;
    private final Entry[] table;
    public Map(){table = new Entry[size];}
    private int buckets(K key){
        if(key == null){
            return 0;
        }
        return Math.abs(key.hashCode() % size);
    }
    public void put(K key, V value){
        int index = buckets(key);
        Entry<K, V> newEntry = new Entry<>(key, value, null);
        if(table[index] == null)
            table[index] = newEntry;
    }
    public void remove(K key){
        int index = buckets(key);
        Entry previous = null;
        Entry entry = table[index];
        while (entry != null){
            if(entry.getKey().equals(key)) {
                entry = entry.getNext();
                table[index] = entry;
                System.out.println("Remove key: " + key);
                return;
            }
        }
    }
    public void display(){
        for(int i = 0; i < size; i++){
            if(table[i] != null){
                Entry currentNode = table[i];
                System.out.printf("Key is %s and value is %s %n", currentNode.getKey(), currentNode.getValue());
            }
        }
    }
}

